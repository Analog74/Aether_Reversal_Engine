#pragma once
namespace bool __stdcall assign_to<boost::spirit::qi::detail::parser_binder<boost::spirit::qi::expect_operator<boost::fusion::cons<boost::spirit::qi::no_case_literal_string<char_const(&)[5],true>,boost::fusion::cons<boost::spirit::qi::optional<boost::spirit::qi::reference<boost::spirit::qi::rule<std::__wrap_iter<char_const*>,boost::spirit::unused_type,boost::spirit::unused_type,boost::spirit::unused_type,boost::spirit::unused_type>const>>,boost::fusion::cons<boost::spirit::qi::reference<boost::spirit::qi::rule<std::__wrap_iter<char_const*>,boost::spirit::unused_type,boost::spirit::unused_type,boost::spirit::unused_type,boost::spirit::unused_type>const>,boost::fusion::cons<boost::spirit::qi::parameterized_nonterminal<boost::spirit::qi::rule<std::__wrap_iter<char_const*>,unsigned_int(bool),boost::spirit::unused_type,boost::spirit::unused_type,boost::spirit::unused_type>,boost::fusion::vector<bool>>,boost::fusion::cons<boost::spirit::qi::reference<boost::spirit::qi::rule<std::__wrap_iter<char_const*>,boost::spirit::unused_type,boost::spirit::unused_type,boost::spirit::unused_type,boost::spirit::unused_type>const>,boost::fusion {
class nil_>>>>>>,mpl_ {
public:
    virtual auto bool_<false>>>(parser_binder param_1, function_buffer * param_2, function_obj_tag param_3);
    // +-99 more methods reconstructed
};
}
